%2d motion when drift term is constant

%% variables and dynamics
t = sdpvar(1,1);
x = sdpvar(2,1);

% b = -0.1;
sigma = 0.1;
f =  [x(2); -(x(1) +x(2) + 0.5*x(1)^3)];
g = sigma * [0;1];


%% unsafe set

theta_c = 5*pi/4; 
Cu = [-0.5; -0.75]; %original parameters
Ru = 0.5;

y = x;

c1f = Ru^2 - (y(1) - Cu(1)).^2 - (y(2) - Cu(2)).^2;

% theta_c = 3*pi/2;
% theta_c = 
w_c = [cos(theta_c); sin(theta_c)];
c2f = w_c(1)*(y(1) - Cu(1)) + w_c(2) * (y(2) - Cu(2)); 
unsafe_cons = [c1f; c2f];


%% put together the constraints

% order = 1;
% order = 2;
% order = 3;
% order = 4; 
% order = 5; 
% order = 6; 
d = 2*order;


x0 = [1; 0];

%% Support Sets
T = 5;
Xmax = 1.5;
Xall = struct('ineq', [t*(T-t); x.*(Xmax-x)], 'eq', []);


Xu = struct('ineq', [c1f; c2f], 'eq', []);
Xuall = struct('ineq', [t*(T-t); Xu.ineq], 'eq', []);


%% polynomials
%polynomial definition
[v, cv, mv] = polynomial([t;x], d);

Lv = jacobian(v, t) + jacobian(v, x)*f + 0.5*g'*hessian(v, x)*g;

v0 = replace(v, [t;x], [0; x0]);

objective = v0;

[put_lie, conslie, coefflie] = constraint_psatz(-Lv, Xall, [t;x], d);
[put_base, consbase, coeffbase] = constraint_psatz(v, Xall, [t;x], d);
[put_unsafe, consunsafe, coeffunsafe] = constraint_psatz(v-1, Xuall, [t;x], d);

cons = [conslie; consbase; consunsafe];
coeff = [coefflie; coeffcost;  cv];

opts = sdpsettings('solver', 'mosek');


[sol,u,Q] = solvesos(cons,objective,opts,coeff);
% , X, vars, d)

%% recovery
phi_rec = value(phi);
lam_rec = value(lam);
v_rec = value(cv)'*mv;
v0_rec = replace(v_rec, [t; x], [0; x0]);
obj_rec = value(objective);

disp(obj_rec)